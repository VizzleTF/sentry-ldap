name: Build and Push Sentry LDAP Image

on:
  schedule:
    # Run daily at 00:00 UTC
    - cron: "0 0 * * *"
  workflow_dispatch:
    inputs:
      force_build:
        description: "Force rebuild of all versions (ignore .built_versions)"
        required: false
        default: "false"
        type: boolean

env:
  GHCR_REGISTRY: ghcr.io
  DOCKERHUB_REGISTRY: docker.io
  GHCR_IMAGE: ${{ github.repository }}
  DOCKERHUB_IMAGE: vizzle/sentry-ldap
  MIN_VERSION: "25.9.0"

jobs:
  check-versions:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    outputs:
      versions_to_build: ${{ steps.get_versions.outputs.versions }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get Sentry releases and filter versions
        id: get_versions
        run: |
          # Get all releases from getsentry/self-hosted
          RELEASES=$(curl -s "https://api.github.com/repos/getsentry/self-hosted/releases?per_page=100")

          # Function to check if version is valid semver (X.Y.Z format)
          is_semver() {
            echo "$1" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'
          }

          # Function to compare semver versions (returns 0 if $1 >= $2)
          semver_gte() {
            local v1=$1
            local v2=$2

            IFS='.' read -r v1_major v1_minor v1_patch <<< "$v1"
            IFS='.' read -r v2_major v2_minor v2_patch <<< "$v2"

            if [ "$v1_major" -gt "$v2_major" ]; then return 0; fi
            if [ "$v1_major" -lt "$v2_major" ]; then return 1; fi
            if [ "$v1_minor" -gt "$v2_minor" ]; then return 0; fi
            if [ "$v1_minor" -lt "$v2_minor" ]; then return 1; fi
            if [ "$v1_patch" -ge "$v2_patch" ]; then return 0; fi
            return 1
          }

          # Read already built versions (skip if force_build)
          if [ "${{ github.event.inputs.force_build }}" = "true" ]; then
            BUILT_VERSIONS=""
            echo "Force build enabled, ignoring .built_versions"
          elif [ -f ".built_versions" ]; then
            BUILT_VERSIONS=$(cat .built_versions)
          else
            BUILT_VERSIONS=""
          fi

          # Parse releases and filter, collect all valid versions
          ALL_VERSIONS=()

          while IFS= read -r tag; do
            # Skip empty tags
            [ -z "$tag" ] && continue

            # Check if it's valid semver
            if ! is_semver "$tag"; then
              echo "Skipping non-semver tag: $tag"
              continue
            fi

            # Check if version >= MIN_VERSION
            if ! semver_gte "$tag" "$MIN_VERSION"; then
              echo "Skipping version below minimum: $tag"
              continue
            fi

            # Skip already built versions
            if echo "$BUILT_VERSIONS" | grep -qx "$tag"; then
              echo "Already built: $tag"
              continue
            fi

            echo "Will build: $tag"
            ALL_VERSIONS+=("$tag")

          done < <(echo "$RELEASES" | jq -r '.[].tag_name')

          # Sort versions ascending (oldest first) so latest is built last
          SORTED_VERSIONS=$(printf '%s\n' "${ALL_VERSIONS[@]}" | sort -V)

          # Convert to JSON array
          VERSIONS_JSON="[]"
          while IFS= read -r version; do
            [ -z "$version" ] && continue
            VERSIONS_JSON=$(echo "$VERSIONS_JSON" | jq -c ". + [\"$version\"]")
          done <<< "$SORTED_VERSIONS"

          echo "Versions to build (oldest to newest): $VERSIONS_JSON"
          echo "versions=$VERSIONS_JSON" >> $GITHUB_OUTPUT

  build:
    needs: check-versions
    if: needs.check-versions.outputs.versions_to_build != '[]'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write

    strategy:
      matrix:
        version: ${{ fromJson(needs.check-versions.outputs.versions_to_build) }}
      max-parallel: 1
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKERHUB_REGISTRY }}
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.GHCR_REGISTRY }}/${{ env.GHCR_IMAGE }}
            ${{ env.DOCKERHUB_REGISTRY }}/${{ env.DOCKERHUB_IMAGE }}
          tags: |
            type=raw,value=${{ matrix.version }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            SENTRY_VERSION=${{ matrix.version }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Sentry Version:** ${{ matrix.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **GHCR Image:** ${{ env.GHCR_REGISTRY }}/${{ env.GHCR_IMAGE }}:${{ matrix.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Hub Image:** ${{ env.DOCKERHUB_REGISTRY }}/${{ env.DOCKERHUB_IMAGE }}:${{ matrix.version }}" >> $GITHUB_STEP_SUMMARY

  update-built-versions:
    needs: [check-versions, build]
    if: always() && needs.build.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update built versions file
        run: |
          VERSIONS='${{ needs.check-versions.outputs.versions_to_build }}'

          # Append new versions to the file
          for version in $(echo "$VERSIONS" | jq -r '.[]'); do
            if ! grep -qx "$version" .built_versions 2>/dev/null; then
              echo "$version" >> .built_versions
            fi
          done

          # Sort versions
          if [ -f ".built_versions" ]; then
            sort -V .built_versions -o .built_versions
          fi

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .built_versions
          git diff --staged --quiet || git commit -m "Update built versions list"
          git push
